<html>
  <head>
<style type="text/css">
.inline {
  background-color: #f7f7f7;
  border:solid 1px #B0B0B0;
}
.error {
	font-weight: bold;
	color: #FF0000;
}
.warning {
	font-weight: bold;
}
.message {
	font-style: italic;
}
.source, .output, .warning, .error, .message {
	padding: 0 1em;
  border:solid 1px #F7F7F7;
}
.source {
  background-color: #f5f5f5;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.center {
  text-align: center;
}
.hl.num {
  color: #AF0F91;
}
.hl.str {
  color: #317ECC;
}
.hl.com {
  color: #AD95AF;
  font-style: italic;
}
.hl.opt {
  color: #000000;
}
.hl.std {
  color: #585858;
}
.hl.kwa {
  color: #295F94;
  font-weight: bold;
}
.hl.kwb {
  color: #B05A65;
}
.hl.kwc {
  color: #55aa55;
}
.hl.kwd {
  color: #BC5A65;
  font-weight: bold;
}
</style>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <style type="text/css">
    @media print {
      body { }
      p.img { text-align: center; page-break-inside: avoid }
      img.CC { display: inline }
    }
    @media screen {
      body { max-width: 800px; margin: auto }
      p.img { text-align: center }
      img.CC { display: inline }
    }
    p.date {
      font-size: smaller;
      margin: 0;
    }
    p.versionHistory {
      color: gray
    }
    p.versionHistory a {
      color: gray
    }
    p.ref {
      text-indent: -2em;
      padding-left: 2em;
    }
    p.fig {
      text-align: left;
    }
    p.fig img, img.plot {
      box-shadow: 10px 10px 20px;
      margin-top: 10px;
      margin-bottom: 20px;      
    }
  </style>
  </head>
  <body>
    <h1>Graphical Definitions in R Graphics</h1>
    <p>
      <span style="font-style: italic">by Paul Murrell</span>
      <a href="http://orcid.org">
        <img alt="" src="https://www.stat.auckland.ac.nz/~paul/ORCID/ORCiD.png" style="width: 16px; height: 16px; vertical-align: middle">
      </a>
      <span style="font-family: mono; font-size: small">
        <a href="http://orcid.org/0000-0002-3224-8858">http://orcid.org/0000-0002-3224-8858</a>
      </span>
    </p>
    <p class="date">
    Version 1:  original publication
  </p>


    <hr>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a><br><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
    <hr>
    <p>
    This document describes a plan to expand the R graphics engine
    to support graphical definitions:  graphical features like gradients,
    patterns, masks, and clipping paths.  
  </p>
    <p>
    The code changes are being 
    tracked in a 
    subversion branch called <code>R-defs</code>.
  </p>
    <p>
    This is a living document that will evolve as the code is developed.
  </p>
    <p>
    The <a href="#features">Features</a> Section outlines the features that I
    would like to target and the
    <a href="#demos">Demonstrations</a> Section provides a glimpse of how some
    new features are currently implemented at the user
    level (in the <code>R-defs</code> branch).
  </p>
    <p>
    The <a href="#internals">Internal details</a> Section has more on the internal design and
    internal code changes
    that have been made.  
  </p>
    <p>
    The <a href="#issues">Issues</a> Section contains some of the major design
    issues that I have identified so far and 
    the <a href="#discussion">Discussion</a> Section contains some questions and
    (some) answers that I have already thought a bit about,
    including the changes that would be imposed
    on graphics device maintainers.
  </p>
    <div>
      <h2>Table of Contents:</h2>
      <ul style="list-style: none">
        <li>
          <a href="#intro">1. Introduction</a>
        </li>
        <li>
          <a href="#issues">2. Issues</a>
        </li>
        <li>
          <a href="#features">3. Features</a>
        </li>
        <li>
          <a href="#demos">4. Demonstrations</a>
        </li>
        <li>
          <a href="#internals">5. Internal details</a>
        </li>
        <li>
          <a href="#discussion">6. Discussion</a>
        </li>
      </ul>
    </div>
    <h2>
      <a name="intro">1. Introduction</a>
    </h2>
    <p>
    The R graphics engine only supports a limited set of graphical 
    features:  basic shapes like lines, rectangles, and circles;
    paths (including shapes with holes);
    text; raster images; and rectangular clipping regions.
    These features are sufficient to produce a wide range of statistical plots,
    but there are many things that R graphics cannot do.
  </p>
    <p>
    For example, the image below contains a set of filled contours within
    a map of New Zealand.  The natural way to achieve this result would
    be to draw the filled contours and apply a clipping path to the
    filled contours based on
    the boundary of New Zealand.  That is 
    not something that can
    be achieved in R graphics (because R graphics only supports
    rectangular clipping regions).<a href="#clippingpathworkaround"><sup>1</sup></a>
  </p>
    <p>
      <img src="gore-nzoverlaypath.png" alt="contour lines clipped to a map">
    </p>
    <p>
    The plan is to add new graphical
    features to the R graphics engine, such as clipping paths,
    in order to expand the range of graphical images that can be produced
    with R.
  </p>
    <h2>
      <a name="issues">2. Issues</a>
    </h2>
    <p>
    There are a number of issues that need to be resolved 
    when adding a new graphics feature to the R graphics engine.
  </p>
    <dl>
      <dt>
      Device-independence:
    </dt>
      <dd>
        <p>
        Can we generate the same output on all R graphics devices?  
      </p>
        <p>
        This
        horse has already bolted.  
        The output on different R graphics devices has never been identical
        and there are already graphics features
        that are not supported on all R graphics devices (e.g.,
        translucent colours are not supported on the PostScript device).
        The plan is to double-down on this approach and just allow
        graphics devices to opt out of any or all of the new features.
      </p>
        <p>
        This is partly because not all devices will be capable
        of supporting the new features and partly because it makes it
        easy to roll out the new features;  graphics devices can 
        initially opt out of all new features and add support as
        and when they are able.
      </p>
      </dd>
      <dt>
<code>SEXP</code>s in graphics devices:
    </dt>
      <dd>
        <p>
        Can we avoid sending R's <code>SEXP</code> structures to
        graphics devices ?
      </p>
        <p>
        In the early days, there was an effort to avoid using R's internal
        C structures within graphics devices (so that they only had to
        include R's graphics-related header files and they did not have to
        worry about complications like R's memory management).
      </p>
        <p>
        This horse has also bolted.  From R 2.13.2 (at least), when the
        <code>cap</code> graphics device procedure was added (to allow
        raster "screen shots" of current device state), devices have
        been able to at least return R structures.
      </p>
        <p>
        The plan is again to double-down.  Some of the new features
        will require sending relatively complex information to the graphics
        device (e.g., gradient information and
        pattern information), so rather than
        define complex new C structures, it makes sense to make use
        of R's existing flexible structures.  
      </p>
        <p>
        One problem is that an SEXP in C is basically an opaque pointer.
        How does the device know about changes to the SEXP structure?
        The proposal is to 
        write a C API for interacting with the SEXP structures
        and encourage
        devices to use  that.  An example has been developed for
        gradient fills (see the 
        <a href="#demos">Demonstrations</a> Section).
      </p>
      </dd>
      <dt>
      The feature set:
    </dt>
      <dd>
        <p>
        How to decide which graphics features to support?
      </p>
        <p>
        This is almost the inverse of the device-independence problem.
        Do we shoot for the union of all features supported by all 
        possible graphics devices ? Or do we target the feature set
        of one particular device or format (e.g., SVG) ?
      </p>
        <p>
        The plan is to take ideas from everywhere.
        There are features that will only be supported by some
        formats (e.g., SVG has filters, but Cairo has only very
        limited filter support, whereas Cairo has mesh patterns,
        but SVG does not).
        There are also subtleties between formats, like the 
        'gradientUnits' in SVG that are not
        supported in Cairo, but we can hopefully make an interface
        for these (at least in 'grid') even if the graphics engine 
        only goes as far as Cairo support.
      </p>
        <p>
        The PDF feature set is probably the most sophisticated (?).
        For example, most graphics formats have linear and radial gradients,
        Cairo graphics has "mesh patterns" that SVG does not,
        but PDF has seven types of "shaders"
        (type 2=Linear gradients, 3=Radial gradients, 
         4&amp;5=Gouraud-shaded triangle meshes,
         6=Coons patch meshes, and 7=Tensor-product patch meshes)
         including Function-based shaders (type 1) that define the
         colour of every point in the image using a mathematical function.
         Gradient meshes have been proposed for SVG, but it 
         <a href="http://libregraphicsworld.org/blog/entry/gradient-meshes-and-hatching-to-be-removed-from-svg-2-0">does
         not look like they will make it into SVG 2.0</a>.
      </p>
      </dd>
      <dt>
      'grid' versus 'graphics'
    </dt>
      <dd>
        <p>
        Will the new features be implemented for 'graphics' or 'grid'
        or both ?
      </p>
        <p>
        The new features will be implemented within the graphics engine.
        This means that, in theory, interfaces can be made for both
        'graphics' and 'grid'.
      </p>
        <p>
        The plan is to focus, initially at least, on 'grid'.
        This is because 
        'grid' allows more flexible and interesting definitions,
        for example, the use of units in locating gradient stops.
        'grid' also allows for things like adding features
        by post-editing because we are able to address graphical
        objects by name.
      </p>
        <p>
        It is also possible in the meantime 
        to apply the new features to 'graphics'
        output via <code>gridGraphics::grid.echo</code>
        and functions like <code>grid::grid.edit</code>.
      </p>
      </dd>
      <dt>
      Graphics devices
    </dt>
      <dd>
        <p>
        Which graphics devices should implement which features ?
      </p>
        <p>
        Obviously, only some features can be added to some graphics devices
        because of limitations in graphics formats and/or graphics 
        libraries.  This issue relates more to <em>when</em> support
        gets added to different graphics devices.  The problem is that
        implementing all possible features on all possible devices
        is a big job (made more difficult by the development environment
        on some platforms, like Windows).
      </p>
        <p>
        The proposal is to be feature-greedy and just
        focus initially on the Cairo graphics devices.
        This gives a reasonable coverage (raster on Linux at least, PDF, 
        and SVG) from a single set of code changes.
        The idea would be to introduce as many features as possible,
        on the Cairo devices, for 4.0.0 and then fill in the gaps.
        Once the Cairo changes are implemented, they will hopefully 
        provide a template so that others 
        could contribute with patches 
        for other devices.
      </p>
        <p>
        A danger is that only implementing for Cairo may "bias" the
        graphics engine implementation towards that device and cause
        problems for implementations on other graphics devices.
        Perhaps implementing for two devices (e.g., also the PDF device)
        rather than one
        would be more prudent.
      </p>
        <p>
        Another issue is that the default, "graphapp", Windows
        device is NOT going to be able to support these features
        very easily (if at all).  GraphApp does not support any
        of these features (?) (even in the 
        <a href="http://enchantia.com/graphapp/doc/manual/">latest version</a>
        and not even the underlying Windows GDI supports gradient fills
        (though it looks like clipping paths are possible).
        OTOH, implementing features on the Cairo device makes them
        available on all platforms (?).
        I am unsure about whether the RStudio plot pane (RStudioGD) will
        be able to support these features (across platforms).
      </p>
        <p>
        Third-party graphics devices can of course update as much as they
        want when they want, though they will have to immediately
        provide some minimal stubs for the changes to the graphics
        device API (<code>GraphicsDevice.h</code>).
      </p>
      </dd>
    </dl>
    <h2>
      <a name="features">3. Features</a>
    </h2>
    <p>
    This section briefly describes
    the set of graphical features that are currently
    being considered.
  </p>
    <dl>
      <dt>
      Gradients
    </dt>
      <dd>
        <p>
        This includes linear gradients and radial gradients.
        Gradients can be applied to both fills and strokes
        (at least on some devices).
      </p>
        <p>
        Gradient meshes are also supported on several devices
        (Cairo and PDF).
      </p>
      </dd>
      <dt>
      Patterns
    </dt>
      <dd>
        <p>
        Pattern fills are similar to gradient fills in that they
        define a "paint" for filling a region.  The difference is
        that a pattern fill is based on "tiling" a smaller image.
      </p>
        <p>
        There are other sorts of pattern fills in some formats
        (e.g., function-based shaders in PDF).
      </p>
      </dd>
      <dt>
      Clipping paths
    </dt>
      <dd>
        <p>
        Allow clipping to an arbitrary path rather than just a 
        rectangle.  This relies on being able to specify a 
        "path" separate from drawing (stroking or filling) it.
      </p>
      </dd>
      <dt>
      Masks
    </dt>
      <dd>
        <p>
        Similar to clipping except that affect translucency of 
        rendered output (rather than just visible or not).
        Again, relies on being able to describe paths without
        drawing them.
      </p>
      </dd>
      <dt>
      Filters
    </dt>
      <dd>
        <p>
        These are essentially raster operations, but a format like
        SVG allows them to be defined as part of a vector image
        (they are applied as part of the rasterization of the
        vector image, for example, when drawing to screen).
      </p>
        <p>
        Implementing these in the graphics engine is probably too hard.
        I don't think any of the standard graphics devices will 
        support them (including the Cairo svg device).
      </p>
        <p>
        These may have to remain the domain of packages like 
        'gridSVG' (which provides full access to SVG features)
        or 'magick' (which allows us to apply raster operations
        to raster images), possibly in combination with
        the 'rasterize' package.
      </p>
        <p>
        It looks like Thomas Lin Pedersen has been thinking along similar lines
        (to the latter) with a
        <a href="https://github.com/thomasp85/ggfx">'ggfx'</a> package.
      </p>
        <!-- Only very limited support in Cairo?  No support in PDF? 
           (see ../../Examples/Filters) -->
      </dd>
    </dl>
    <h2>
      <a name="demos">4. Demonstrations</a>
    </h2>
    <p>
    A new <a href="https://svn.r-project.org/R/branches/R-defs/"><code>R-defs</code></a> 
    branch has been created for experimenting.
    So far, that includes the addition of support for
    linear and radial gradient fills, patterns, clipping paths, and masks
    on both Cairo graphics devices and the <code>pdf</code> device
    (except for patterns),
    with a 'grid' interface.  The following set of examples
    show how the 'grid' interface has been implemented so far.
  </p>
    <p>
      <strong>NOTE: support for graphics definitions has only been implemented
    for Cairo-based graphics devices and the <code>pdf</code> device
    so far.  Other graphics devices 
    should run, but will not produce output from graphics definitions.
    Third-party graphics devices will hopefully error out (if they make
    use of <code>R_GE_checkVersionOrDie</code>), but otherwise they
    are likely to segfault until they are updated.</strong>
    </p>
    <p>
    On the positive side, Cairo devices and the <code>pdf</code> device
    can be used on all major platforms,
    so there is already an option for accessing these new features
    on all major platforms.
  </p>
    <h3>Gradients</h3>
    <p>
    The <code>fill</code> gpar can now be a linear gradient 
    (as well as a normal R colour).
  </p>
<div class="chunk" id="unnamed-chunk-2"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">library</span><span class="hl std">(grid)</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">()))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-2-1.svg" title="plot of chunk unnamed-chunk-2" alt="plot of chunk unnamed-chunk-2" class="plot" /></div></div>
    <p>
    A linear gradient is defined by a start point (default: bottom-left)
    and an end point (default: top-right) and a series of "stops".
    Each stop is defined by a position on the line from start point to
    end point, plus a colour.  If the first stop is not at the start 
    point, or the last stop is not at the end point, we can specify
    how the gradient "extends" beyond the first and last stops.
  </p>
    <p>
    The following code creates a linear gradient that starts one inch
    off the bottom of the image, proceeds vertically to the top of the image,
    and transitions from red to yellow then back to red.
  </p>
    <!-- produce PNG for this one because SVG does NOT have 
       spreadMethod="none" (so Cairo SVG just uses "pad") -->
<div class="chunk" id="unnamed-chunk-3"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;red&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;yellow&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;red&quot;</span><span class="hl std">),</span>
                                      <span class="hl kwd">c</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">,</span> <span class="hl num">.5</span><span class="hl std">,</span> <span class="hl num">1</span><span class="hl std">),</span>
                                      <span class="hl kwc">x1</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">y1</span><span class="hl std">=</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl str">&quot;in&quot;</span><span class="hl std">),</span>
                                      <span class="hl kwc">x2</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">y2</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl std">,</span>
                                      <span class="hl kwc">extend</span><span class="hl std">=</span><span class="hl str">&quot;none&quot;</span><span class="hl std">)))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-3-1.png" title="plot of chunk unnamed-chunk-3" alt="plot of chunk unnamed-chunk-3" class="plot" /></div></div>
    <p>
    When the gradient fill is specified on a grob, 
    the start and end points are relative to the grob bounding box.
    The following code fills a rectangle in the central quarter of the
    image with the default linear gradient;  the gradient
    starts at the bottom-left of the rectangle and ends at the top-right
    of the rectangle.
  </p>
<div class="chunk" id="unnamed-chunk-4"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span>
          <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">()))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-4-1.svg" title="plot of chunk unnamed-chunk-4" alt="plot of chunk unnamed-chunk-4" class="plot" /></div></div>
    <p>
    A gradient fill can also be specified on a viewport, in which case
    the gradient is relative to the viewport and all subsequent
    drawing makes use of that gradient (unless a new explicit fill is
    specified).
  </p>
    <p>
    In the code below, we push a viewport that fills the whole image 
    and specify the default linear gradient fill, so the gradient
    is relative to the whole image.
    We then draw a rectangle, with no explicit fill, so it
    "inherits" the gradient from the viewport.
  </p>
<div class="chunk" id="vppattern"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">())))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">()</span>
</pre></div>
</div><div class="rimage default"><img src="figure/vppattern-1.svg" title="plot of chunk vppattern" alt="plot of chunk vppattern" class="plot" /></div></div>
    <p>
    In the next example, we have the same viewport, but we draw
    the rectangle only in the central quarter of the image.  This
    shows that the gradient that the rectangle inherits is relative
    to the viewport rather than being relative to the rectangle.
  </p>
<div class="chunk" id="unnamed-chunk-5"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">())))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-5-1.svg" title="plot of chunk unnamed-chunk-5" alt="plot of chunk unnamed-chunk-5" class="plot" /></div></div>
    <p>
    The next example shows another variation on inheritance of gpar 
    settings.  This time a viewport is pushed with the default
    linear gradient and we draw a rectangle in the left third of the 
    image that inherits that gradient (relative to the viewport).
    Then we push another viewport with a green fill and draw a rectangle
    within that viewport (in the centre of the image) and that rectangle
    inherits the green fill.  Finally, we pop the second viewport and
    return to the first viewport and restore its linear gradient
    so that when we draw
    a rectangle in the right third of the image it again inherits
    the linear gradient (relative to the viewport).  
  </p>
<div class="chunk" id="unnamed-chunk-6"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">())))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=</span><span class="hl num">.2</span><span class="hl std">,</span> <span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.2</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl str">&quot;green&quot;</span><span class="hl std">)))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.2</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)</span>
<span class="hl kwd">popViewport</span><span class="hl std">()</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=</span><span class="hl num">.8</span><span class="hl std">,</span> <span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.2</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-6-1.svg" title="plot of chunk unnamed-chunk-6" alt="plot of chunk unnamed-chunk-6" class="plot" /></div></div>
    <p>
    The next example also demonstrates inheritance of gpar settings,
    but this time it is inheritance between viewports.
    We push a viewport with the default gradient, then push another
    viewport in the central quarter of the image, then draw a rectangle.
    The second viewport inherits the gradient from the first viewport and
    then the rectangle inherits the gradient from the second viewport.
    The important point is that the gradient is relative to the first
    viewport, which is where it was defined.
  </p>
<div class="chunk" id="unnamed-chunk-7"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">())))</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">()</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-7-1.svg" title="plot of chunk unnamed-chunk-7" alt="plot of chunk unnamed-chunk-7" class="plot" /></div></div>
    <p>
    The next example just shows that gradients work with
    translucent colours.  We draw the text "Reveal" then over the
    top draw a rect with a gradient fill that transitions from
    (opaque) white to transparent.
  </p>
<div class="chunk" id="unnamed-chunk-8"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;Reveal&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fontface</span><span class="hl std">=</span><span class="hl str">&quot;bold&quot;</span><span class="hl std">,</span> <span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;white&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;transparent&quot;</span><span class="hl std">),</span>
                                      <span class="hl kwc">x1</span><span class="hl std">=</span><span class="hl num">.2</span><span class="hl std">,</span> <span class="hl kwc">x2</span><span class="hl std">=</span><span class="hl num">.8</span><span class="hl std">,</span> <span class="hl kwc">y1</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">y2</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-8-1.svg" title="plot of chunk unnamed-chunk-8" alt="plot of chunk unnamed-chunk-8" class="plot" /></div></div>
    <p>
    The next example shows that radial gradients work via
    the same interface.  It is expected that fill patterns would
    work the same way.
  </p>
<div class="chunk" id="unnamed-chunk-9"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">radialGradient</span><span class="hl std">()))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-9-1.svg" title="plot of chunk unnamed-chunk-9" alt="plot of chunk unnamed-chunk-9" class="plot" /></div></div>
    <p>
    As with linear gradients, we have control over the start and end
    of the radial gradient, though in the radial case it is a start circle
    and an end circle.  In the code below, we make a gradient that starts
    near the top right of the image (with white) and ends with a circle 
    that fills the image (black).
  </p>
<div class="chunk" id="unnamed-chunk-10"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">radialGradient</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;white&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;black&quot;</span><span class="hl std">),</span>
                                      <span class="hl kwc">cx1</span><span class="hl std">=</span><span class="hl num">.8</span><span class="hl std">,</span> <span class="hl kwc">cy1</span><span class="hl std">=</span><span class="hl num">.8</span><span class="hl std">)))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-10-1.svg" title="plot of chunk unnamed-chunk-10" alt="plot of chunk unnamed-chunk-10" class="plot" /></div></div>
    <p>
    The next example shows that we can add a gradient to an
    existing image, in this case a 'ggplot2' plot.
    Here we edit the background of the plot panel to add
    a grey-to-white gradient.
  </p>
<div class="chunk" id="unnamed-chunk-11"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">library</span><span class="hl std">(ggplot2)</span>
<span class="hl kwd">ggplot</span><span class="hl std">(mtcars)</span> <span class="hl opt">+</span>
    <span class="hl kwd">geom_point</span><span class="hl std">(</span><span class="hl kwd">aes</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=disp,</span> <span class="hl kwc">y</span><span class="hl std">=mpg))</span> <span class="hl opt">+</span>
    <span class="hl kwd">theme_bw</span><span class="hl std">()</span>
<span class="hl kwd">grid.force</span><span class="hl std">()</span>
<span class="hl kwd">grid.edit</span><span class="hl std">(</span><span class="hl str">&quot;panel.background&quot;</span><span class="hl std">,</span> <span class="hl kwc">grep</span><span class="hl std">=</span><span class="hl num">TRUE</span><span class="hl std">,</span>
          <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;white&quot;</span><span class="hl std">),</span> <span class="hl kwc">x1</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">x2</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-11-1.svg" title="plot of chunk unnamed-chunk-11" alt="plot of chunk unnamed-chunk-11" class="plot" /></div></div>
    <p>
    The next example is similar, but demonstrates that, even with
    gradients only implemented in 'grid', we can still add gradients
    to 'graphics' plots if we first convert them using the 
    'gridGraphics' package.
  </p>
<div class="chunk" id="unnamed-chunk-12"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">plot</span><span class="hl std">(mpg</span> <span class="hl opt">~</span> <span class="hl std">disp, mtcars,</span> <span class="hl kwc">pch</span><span class="hl std">=</span><span class="hl num">16</span><span class="hl std">)</span>
<span class="hl kwd">library</span><span class="hl std">(gridGraphics)</span>
<span class="hl kwd">grid.echo</span><span class="hl std">()</span>
<span class="hl std">g</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">grid.grab</span><span class="hl std">()</span>
<span class="hl std">box</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">grid.grep</span><span class="hl std">(</span><span class="hl str">&quot;box&quot;</span><span class="hl std">, g,</span> <span class="hl kwc">grep</span><span class="hl std">=</span><span class="hl num">TRUE</span><span class="hl std">)</span>
<span class="hl std">g</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">editGrob</span><span class="hl std">(g, box</span><span class="hl opt">$</span><span class="hl std">name,</span>
              <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;white&quot;</span><span class="hl std">),</span> <span class="hl kwc">x1</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">x2</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)))</span>
<span class="hl std">g</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">reorderGrob</span><span class="hl std">(g, box</span><span class="hl opt">$</span><span class="hl std">name)</span>
<span class="hl kwd">grid.newpage</span><span class="hl std">()</span>
<span class="hl kwd">grid.draw</span><span class="hl std">(g)</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-12-1.svg" title="plot of chunk unnamed-chunk-12" alt="plot of chunk unnamed-chunk-12" class="plot" /></div></div>
    <h3>Patterns</h3>
    <p>
    The <code>fill</code> gpar can also be a general pattern that is based
    on a 'grid' grob. The <code>pattern</code> function takes a grob
    and draws it as the fill for another grob.
  </p>
<div class="chunk" id="unnamed-chunk-13"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">pat</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">pattern</span><span class="hl std">(</span><span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl opt">/</span><span class="hl num">4</span><span class="hl std">,</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">5</span><span class="hl std">,</span> <span class="hl str">&quot;mm&quot;</span><span class="hl std">),</span>
                          <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;red&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;green&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;blue&quot;</span><span class="hl std">))))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=pat))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-13-1.svg" title="plot of chunk unnamed-chunk-13" alt="plot of chunk unnamed-chunk-13" class="plot" /></div></div>
    <p>
    Patterns on grobs are relative to the grob.
  </p>
<div class="chunk" id="unnamed-chunk-14"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">pat</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">pattern</span><span class="hl std">(</span><span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl opt">/</span><span class="hl num">4</span><span class="hl std">,</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">5</span><span class="hl std">,</span> <span class="hl str">&quot;mm&quot;</span><span class="hl std">),</span>
                          <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;red&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;green&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;blue&quot;</span><span class="hl std">))))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=pat))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-14-1.svg" title="plot of chunk unnamed-chunk-14" alt="plot of chunk unnamed-chunk-14" class="plot" /></div></div>
    <p>
    Patterns on viewports are relative to the viewport.
  </p>
<div class="chunk" id="unnamed-chunk-15"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">pat</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">pattern</span><span class="hl std">(</span><span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl opt">/</span><span class="hl num">4</span><span class="hl std">,</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">5</span><span class="hl std">,</span> <span class="hl str">&quot;mm&quot;</span><span class="hl std">),</span>
                          <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;red&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;green&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;blue&quot;</span><span class="hl std">))))</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=pat)))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-15-1.svg" title="plot of chunk unnamed-chunk-15" alt="plot of chunk unnamed-chunk-15" class="plot" /></div></div>
    <p>
    Patterns are full drawings so can have gradients and clipping (see 
    "Clipping paths" below).
  </p>
<div class="chunk" id="unnamed-chunk-16"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">pat</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl opt">/</span><span class="hl num">4</span><span class="hl std">,</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">5</span><span class="hl std">,</span> <span class="hl str">&quot;mm&quot;</span><span class="hl std">),</span>
                  <span class="hl kwc">vp</span><span class="hl std">=</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">clip</span><span class="hl std">=</span><span class="hl kwd">rectGrob</span><span class="hl std">(</span><span class="hl kwc">height</span><span class="hl std">=</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">5</span><span class="hl std">,</span> <span class="hl str">&quot;mm&quot;</span><span class="hl std">)),</span>
                              <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">linearGradient</span><span class="hl std">(</span><span class="hl kwc">y1</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">y2</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">))))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">pattern</span><span class="hl std">(pat)))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-16-1.svg" title="plot of chunk unnamed-chunk-16" alt="plot of chunk unnamed-chunk-16" class="plot" /></div></div>
    <p>
    One way to generate a pattern that fills the page is to 
    write a grob with a <code>makeContent</code> method.
  </p>
<div class="chunk" id="unnamed-chunk-17"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">pat</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">grob</span><span class="hl std">(</span><span class="hl kwc">cl</span><span class="hl std">=</span><span class="hl str">&quot;polkadots&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">col</span><span class="hl std">=</span><span class="hl num">NA</span><span class="hl std">,</span> <span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl std">makeContent.polkadots</span> <span class="hl kwb">&lt;-</span> <span class="hl kwa">function</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">) {</span>
    <span class="hl std">w</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">convertWidth</span><span class="hl std">(</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl str">&quot;npc&quot;</span><span class="hl std">),</span> <span class="hl str">&quot;cm&quot;</span><span class="hl std">,</span> <span class="hl kwc">valueOnly</span><span class="hl std">=</span><span class="hl num">TRUE</span><span class="hl std">)</span>
    <span class="hl std">h</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">convertHeight</span><span class="hl std">(</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl str">&quot;npc&quot;</span><span class="hl std">),</span> <span class="hl str">&quot;cm&quot;</span><span class="hl std">,</span> <span class="hl kwc">valueOnly</span><span class="hl std">=</span><span class="hl num">TRUE</span><span class="hl std">)</span>
    <span class="hl std">x</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">seq</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">,</span> <span class="hl kwd">ceiling</span><span class="hl std">(w))</span>
    <span class="hl std">y</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">seq</span><span class="hl std">(</span><span class="hl num">0</span><span class="hl std">,</span> <span class="hl kwd">ceiling</span><span class="hl std">(h))</span>
    <span class="hl std">xy</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">expand.grid</span><span class="hl std">(x, y)</span>
    <span class="hl kwd">circleGrob</span><span class="hl std">(xy</span><span class="hl opt">$</span><span class="hl std">Var1, xy</span><span class="hl opt">$</span><span class="hl std">Var2,</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl kwd">unit</span><span class="hl std">(</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl str">&quot;mm&quot;</span><span class="hl std">),</span> <span class="hl kwc">default.units</span><span class="hl std">=</span><span class="hl str">&quot;cm&quot;</span><span class="hl std">)</span>
<span class="hl std">}</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">pattern</span><span class="hl std">(pat))))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">)</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-17-1.svg" title="plot of chunk unnamed-chunk-17" alt="plot of chunk unnamed-chunk-17" class="plot" /></div></div>
    <h3>Clipping paths</h3>
    <p>
    The <code>clip</code> argument for the <code>viewport</code> function
    can be a 'grid' grob (in addition to the existing 
    <code>"on"</code>, which only enforces a rectangular clipping region).   
    The grob defines a path that is used
    to set the clipping region.
  </p>
    <p>
    A simple example is clipping output (in this case text) to a circle.
    The text and the circle are both drawn in grey and then the text
    is drawn black with the circle used as a clipping path.
  </p>
<div class="chunk" id="unnamed-chunk-18"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;testing&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl std">cg</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl kwc">r</span><span class="hl std">=</span><span class="hl num">.25</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl kwd">grid.draw</span><span class="hl std">(cg)</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">clip</span><span class="hl std">=cg))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;testing&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-18-1.svg" title="plot of chunk unnamed-chunk-18" alt="plot of chunk unnamed-chunk-18" class="plot" /></div></div>
    <p>
    A slightly more dramatic example involves clipping text to several
    circles at once.  Note that this still only requires a single
    grob to specify the clipping path.
  </p>
<div class="chunk" id="unnamed-chunk-19"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;testing&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl std">cg</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl opt">/</span><span class="hl num">4</span><span class="hl std">,</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl num">.1</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl kwd">grid.draw</span><span class="hl std">(cg)</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">clip</span><span class="hl std">=cg))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;testing&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-19-1.svg" title="plot of chunk unnamed-chunk-19" alt="plot of chunk unnamed-chunk-19" class="plot" /></div></div>
    <p>
    The clipping path is relative to the viewport and
    clipping paths are inherited like the existing <code>clip</code>
    settings.  
  </p>
    <p>
    In the following code (after drawing everything in grey 
    without any clipping), we push a viewport with three circles as the
    clipping path, then we draw the text "test one", which gets clipped
    to the circles.  Next, we push another viewport in the bottom third
    of the image, which inherits the clipping path, and we draw the text
    "test two", which also gets clipped to the circles.  Finally, 
    we pop those two viewports and push a third viewport in the top
    third of the image;  now there is no clipping path in effect (because
    we popped the viewport with a clipping path), so when we
    draw the text "test three" the text is not clipped at all.
  </p>
<div class="chunk" id="unnamed-chunk-20"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">cg</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl kwc">y</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl opt">:</span><span class="hl num">3</span><span class="hl opt">/</span><span class="hl num">4</span><span class="hl std">,</span> <span class="hl kwc">r</span><span class="hl std">=</span><span class="hl num">.1</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;test one&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl kwd">grid.draw</span><span class="hl std">(cg)</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">y</span><span class="hl std">=</span><span class="hl num">0</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl opt">/</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl kwc">just</span><span class="hl std">=</span><span class="hl str">&quot;bottom&quot;</span><span class="hl std">))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;test two&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl kwd">popViewport</span><span class="hl std">()</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">clip</span><span class="hl std">=cg))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;test one&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">y</span><span class="hl std">=</span><span class="hl num">0</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl opt">/</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl kwc">just</span><span class="hl std">=</span><span class="hl str">&quot;bottom&quot;</span><span class="hl std">))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;test two&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
<span class="hl kwd">popViewport</span><span class="hl std">(</span><span class="hl num">2</span><span class="hl std">)</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">y</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">1</span><span class="hl opt">/</span><span class="hl num">3</span><span class="hl std">,</span> <span class="hl kwc">just</span><span class="hl std">=</span><span class="hl str">&quot;top&quot;</span><span class="hl std">))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;test three&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-20-1.svg" title="plot of chunk unnamed-chunk-20" alt="plot of chunk unnamed-chunk-20" class="plot" /></div></div>
    <p>
    Clipping paths are just paths (outlines of shapes), they do not
    reflect, for example, stroke width or fill colours.
  </p>
<div class="chunk" id="unnamed-chunk-21"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">path</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl kwc">r</span><span class="hl std">=</span><span class="hl num">.3</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">lwd</span><span class="hl std">=</span><span class="hl num">30</span><span class="hl std">,</span> <span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">,</span> <span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl num">NA</span><span class="hl std">))</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;testing&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">col</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">,</span> <span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">clip</span><span class="hl std">=path))</span>
<span class="hl kwd">grid.draw</span><span class="hl std">(path)</span>
<span class="hl kwd">grid.circle</span><span class="hl std">(</span><span class="hl kwc">r</span><span class="hl std">=</span><span class="hl num">.3</span><span class="hl std">)</span>
<span class="hl kwd">grid.text</span><span class="hl std">(</span><span class="hl str">&quot;testing&quot;</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">cex</span><span class="hl std">=</span><span class="hl num">3</span><span class="hl std">))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-21-1.svg" title="plot of chunk unnamed-chunk-21" alt="plot of chunk unnamed-chunk-21" class="plot" /></div></div>
    <p>
    Although a clipping path can be an arbitrary 'grid' grob,
    clipping and masks (see below) are disallowed within a clipping path.
    Any viewport that sets <code>clip=TRUE</code> or <code>clip=FALSE</code>
    or sets <code>clip</code> to be a grob, or that sets <code>mask</code>
    to be a grob, will generate a warning and the clipping setting
    (or the mask) will be ignored for determining the clipping path.
  </p>
    <p>
    This constraint has been applied for several reasons:
    to make life easier for graphics devices;
    because it is very difficult or impossible to achieve
    some nested clipping effects on some devices;
    formats like PDF and SVG enforce limits on what can go
    in a clipping path;  and fancy clipping shapes can be 
    achieved by using a mask instead.
  </p>
    <h3>Masks</h3>
    <p>
    A 'grid' viewport can now have a <code>mask</code> (in addition to
    <code>clip</code>).  This value should be either <code>"inherit"</code>
    (the default), in which case the viewport inherits the mask from
    its parent, <code>"none"</code>, in which case the viewport does not
    mask its content, or a 'grid' grob that defines a new mask for the
    viewport.
  </p>
    <p>
    The following example defines a circle grob with a 
    radial gradient fill that
    starts at black in the centre and gradually transitions to
    transparent at the circumference.
    A viewport is pushed with this circle grob as the mask, then
    a rectangle is drawn half the width of the viewport and 
    filled with solid black.
    The result is that only the parts of the rectangle where
    the mask is non-transparent are drawn;  the retangle is filtered
    by the mask.
  </p>
<div class="chunk" id="unnamed-chunk-22"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">mask</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">col</span><span class="hl std">=</span><span class="hl num">NA</span><span class="hl std">,</span>
                           <span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl kwd">radialGradient</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;black&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;transparent&quot;</span><span class="hl std">))))</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">mask</span><span class="hl std">=mask))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl str">&quot;black&quot;</span><span class="hl std">))</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-22-1.svg" title="plot of chunk unnamed-chunk-22" alt="plot of chunk unnamed-chunk-22" class="plot" /></div></div>
    <p>
    The following code blends two 'ggplot2' plots using a mask.
    This time the mask is a linear gradient from black 30%
    of the way up the page to transparent 70% of the way up the page.
    First, we draw a plot with the default ggplot2 them, 
    then we draw a black-and-white themed version of the same
    plot on top, using the mask, so from 30% up the page the 
    black-and-white plot transitions smoothly into the default themed plot.
  </p>
<div class="chunk" id="unnamed-chunk-23"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">gg1</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">ggplot</span><span class="hl std">(mtcars)</span> <span class="hl opt">+</span>
    <span class="hl kwd">geom_point</span><span class="hl std">(</span><span class="hl kwd">aes</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=disp,</span> <span class="hl kwc">y</span><span class="hl std">=mpg))</span>
<span class="hl std">gg2</span> <span class="hl kwb">&lt;-</span> <span class="hl std">gg1</span> <span class="hl opt">+</span>
    <span class="hl kwd">theme_bw</span><span class="hl std">()</span>
<span class="hl std">grad</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">linearGradient</span><span class="hl std">(</span><span class="hl kwd">c</span><span class="hl std">(</span><span class="hl str">&quot;black&quot;</span><span class="hl std">,</span> <span class="hl str">&quot;transparent&quot;</span><span class="hl std">),</span> <span class="hl kwc">x1</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">x2</span><span class="hl std">=</span><span class="hl num">.5</span><span class="hl std">,</span> <span class="hl kwc">y1</span><span class="hl std">=</span><span class="hl num">.3</span><span class="hl std">,</span> <span class="hl kwc">y2</span><span class="hl std">=</span><span class="hl num">.7</span><span class="hl std">)</span>
<span class="hl std">mask</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">rectGrob</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">col</span><span class="hl std">=</span><span class="hl num">NA</span><span class="hl std">,</span> <span class="hl kwc">fill</span><span class="hl std">=grad))</span>
<span class="hl kwd">print</span><span class="hl std">(gg1)</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">mask</span><span class="hl std">=mask))</span>
<span class="hl kwd">print</span><span class="hl std">(gg2,</span> <span class="hl kwc">newpage</span><span class="hl std">=</span><span class="hl num">FALSE</span><span class="hl std">)</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-23-1.svg" title="plot of chunk unnamed-chunk-23" alt="plot of chunk unnamed-chunk-23" class="plot" /></div></div>
    <p>
    Here is an example of a relatively complex mask that cannot be 
    achieved with clipping paths (in the current proposal) because
    it would require nesting clipping paths.
    The mask consists of two narrow rectangles, but the left
    rectangle is drawn within a viewport with a clipping path.
    The same effect could be achieved by replacing the clipping path
    with a mask (nested masks are ok).
  </p>
<div class="chunk" id="unnamed-chunk-24"><div class="rcode"><div class="source"><pre class="knitr r"><span class="hl std">mask</span> <span class="hl kwb">&lt;-</span> <span class="hl kwd">gTree</span><span class="hl std">(</span><span class="hl kwc">children</span><span class="hl std">=</span><span class="hl kwd">gList</span><span class="hl std">(</span><span class="hl kwd">rectGrob</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=</span><span class="hl num">.25</span><span class="hl std">,</span> <span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.3</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.8</span><span class="hl std">,</span>
                                      <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl str">&quot;black&quot;</span><span class="hl std">),</span>
                                      <span class="hl kwc">vp</span><span class="hl std">=</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">clip</span><span class="hl std">=</span><span class="hl kwd">circleGrob</span><span class="hl std">(</span><span class="hl kwc">r</span><span class="hl std">=</span><span class="hl num">.4</span><span class="hl std">))),</span>
                             <span class="hl kwd">rectGrob</span><span class="hl std">(</span><span class="hl kwc">x</span><span class="hl std">=</span><span class="hl num">.75</span><span class="hl std">,</span> <span class="hl kwc">width</span><span class="hl std">=</span><span class="hl num">.3</span><span class="hl std">,</span> <span class="hl kwc">height</span><span class="hl std">=</span><span class="hl num">.8</span><span class="hl std">,</span>
                                      <span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl str">&quot;black&quot;</span><span class="hl std">))))</span>
<span class="hl kwd">pushViewport</span><span class="hl std">(</span><span class="hl kwd">viewport</span><span class="hl std">(</span><span class="hl kwc">mask</span><span class="hl std">=mask))</span>
<span class="hl kwd">grid.rect</span><span class="hl std">(</span><span class="hl kwc">gp</span><span class="hl std">=</span><span class="hl kwd">gpar</span><span class="hl std">(</span><span class="hl kwc">fill</span><span class="hl std">=</span><span class="hl str">&quot;grey&quot;</span><span class="hl std">))</span>
<span class="hl kwd">popViewport</span><span class="hl std">()</span>
</pre></div>
</div><div class="rimage default"><img src="figure/unnamed-chunk-24-1.svg" title="plot of chunk unnamed-chunk-24" alt="plot of chunk unnamed-chunk-24" class="plot" /></div></div>
    <h2>
      <a name="internals">5. Internal details</a>
    </h2>
    <h3>Gradients</h3>
    <p>
    A <code>patternFill</code>
    property has been added to the <code>R_GE_gcontext</code> 
    (graphical context)
    in the graphics engine.
    This property can be either <code>NULL</code> 
    (indicating no pattern fill) or an R object, which
    represents a reference to one of the current pattern fills on
    the graphics device.
  </p>
    <p>
    This property is in addition to the existing <code>fill</code>
    property.  If <code>patternFill</code> is non-<code>NULL</code>
    then it overrides <code>fill</code>.  This makes it easy
    for a graphics device to ignore <code>patternFill</code> 
    if it wants to.
  </p>
    <p>
    A <code>grDevices::linearGradient</code> function has been added.
    This is not meant to be called
    directly by users;  it is there for 'graphics' and 'grid' to use.
    The idea is the 'graphics' and 'grid' have user-level 
    interfaces to define gradients and those are 
    converted to graphics engine versions of the gradients
    for drawing.  There is also a <code>grDevices::radialGradient</code>.
  </p>
    <p>
    A <code>setPattern</code> device function has been added to
    allow the graphics engine to ask a graphics device to create
    a pattern.  The function takes a <code>"Pattern"</code> object
    (either a linear or radial gradient so far) and returns an R object
    (a reference to be used in a <code>patternFill</code> call).
  </p>
    <p>
    (A graphics device can just always return <code>NULL</code>
    if it generates
    a new pattern every time <code>setPattern</code> is called ?)
  </p>
    <p>
    There is also a <code>releasePattern</code> device function
    so that, e.g., 'grid' can release a pattern that is just set on
    a grob (and release all patterns on new page).  Specify 
    <code>NULL</code>
    to release all patterns.
  </p>
    <p>
    NOTE that the <code>"Pattern"</code> sent to 
    <code>setPattern</code> is an SEXP,
    which means it is sort of an opaque pointer in C code,
    so the graphics engine provides a C API for extracting 
    information from a <code>"Pattern"</code> object.
    For example, 
    <code>R_GE_isPattern</code> can be called to check for a pattern fill,
    <code>R_GE_patternType</code> can be called to get the pattern type, and
    <code>R_GE_linearGradientNumStops</code> can be called
    to get the number of stops from a <code>LinearGradient</code> SEXP.
  </p>
    <p>
    The Cairo graphics device (<code>x11(type="cairo")</code>, 
    <code>png(type="cairo")</code>, 
    <code>cairo_pdf()</code>, and <code>svg()</code>) 
    has implemented <code>setPattern</code> 
    and <code>releasePattern</code> and maintains an array
    of patterns.  It observes the new
    <code>R_GE_gcontext.gradientFill</code> setting
    and uses the value
    as an index into its array of patterns.
  </p>
    <p>
    The 'grid' package provides its own <code>linearGradient</code> 
    function for defining a linear gradient in 'grid'.
    One notable difference is that the start and end points for
    the gradient can be defined using 'grid' units.
    The <code>gpar</code> function now also allows
    a <code>GridPattern</code> as the value for the 
    <code>fill</code> property.
  </p>
    <p>
    When gpar settings are enforced during drawing a grob, a
    pattern fill is resolved to a graphics engine
    <code>Pattern</code> (for example, the start and end 
    points for a linear gradient are converted to locations on the graphics
    device).
    If the pattern fill is specified on a viewport, the pattern definition
    is relative to that viewport; if the pattern fill is specified 
    on a grob, then the pattern definition is
    relative to the bounding box of the grob.
  </p>
    <p>
    'grid' calls <code>setPattern</code> to "resolve" a pattern
    and generates a <code>GridResolvedPattern</code>, which contains
    the reference from <code>setPattern</code>.  This allows
    'grid' to reuse the pattern reference, e.g., when drawing
    multiple shapes from a single grob, or when revisiting a 
    viewport (so that it does not have to ask the graphics device
    for a new pattern for every shape or for every visit to a viewport).
  </p>
    <p>
    When drawing a grob, 'grid' resolves the pattern relative to the grob,
    gets the pattern reference and uses that for every shape that is drawn
    from this grob, then releases the pattern.
  </p>
    <p>
    When pushing a viewport, 'grid' resolves 
    the pattern relative to the viewport
    and stores the resolved pattern in the pushed viewport, so that
    revisits to the viewport can reuse the resolved pattern.
    The resolved pattern is only stored in the pushed viewport so
    that replays of the grid display list (e.g., <code>grid.edit</code>)
    or the graphics engine display list (e.g., device resize or 
    device copy) will always resolve the pattern again.
  </p>
    <p>
    When starting a new page, 'grid' releases all patterns.
  </p>
    <h3>Patterns</h3>
    <p>
    Patterns use the same <code>R_GE_context</code> slot as gradients;
    a drawing can have a gradient OR a pattern fill OR a normal fill.
    Patterns are passed to graphics devices via the same 
    <code>setPattern</code> device function.
  </p>
    <p>
    There is a <code>grDevices::functionPattern</code> function for
    'graphics' and 'grid' to use to create a pattern.
  </p>
    <p>
    'grid' creates a <code>GridFunctionPattern</code> object,
    which is a list with a component, <code>f</code>,
    that contains a function to draw the grob that defines the pattern.
  </p>
    <p>
    The Cairo graphics device creates a pattern by running the pattern
    function within a <code>cairo_push_group</code> and 
    <code>cairo_pop_group</code>.  This means that the pattern
    is drawn on a temporary surface and that drawing is turned into
    a Cairo pattern to use as the source for filling other drawing.
  </p>
    <p>
    The same pattern resolution in 'grid' is used as for gradients;
    the same pattern array on the Cairo device is used as for gradients.
  </p>
    <h3>Clipping paths</h3>
    <p>
    A <code>setClipPath</code> device function has been added to allow
    the graphics engine (or graphics systems) to ask a device to 
    define a clipping path.  The function takes a <code>path</code>
    and a <code>ref</code> and should return a reference to
    the clipping path on the device.  All three values are SEXPs,
    but all the device needs to know about the <code>path</code> is that
    it is an R function (with no arguments) that the device should
    call to create the clipping path.  More on how that works in a second.
    All the graphics engine (or graphics systems) need to know about the
    reference to a clipping path is ... nothing.  These references are
    generated by the device, passed back to the graphics engine, then
    sent in again to the device.  The graphics engine (or graphics
    systems) only store the references and pass them back to the device;
    the references only have
    meaning within the graphics device.
  </p>
    <p>
    There is also a <code>releaseClipPath</code> device function,
    which takes a reference to a clipping path so that the graphics engine
    (or graphics systems) can indicate to the device that a clipping path
    is no longer required.
  </p>
    <p>
    When a 'grid' viewport is created with a grob as the <code>clip</code>
    argument, a <code>"GridClipPath"</code> object is created, which
    is a function that draws the grob.  When a 'grid' viewport is pushed,
    the clipping path is "resolved" by calling <code>setClipPath</code>
    on the graphics device
    (via R and C interface functions in the 'grDevices' package).
  </p>
    <p>
    The Cairo device maintains an array of clipping paths.
    When a new clipping path is requested (with a call to 
    <code>setClipPath</code>) the device starts a new path
    and enters an "append mode"
    before it runs the R function
    that defines the clipping path.  Cairo device functions that perform
    drawing (e.g., <code>Cairo_Rect</code>) only <em>append</em> shapes to
    the current path when the device is in "append mode" (when not in
    append mode, these device functions start a new path, add the shape
    to the path, set
    parameters like colour, then stroke and/or fill the path).
    After the R function has run, the path is closed and the clipping
    region is set from the path.
    The path is also saved in the array of clipping paths and 
    an integer index to array is returned as the reference (as an
    R integer vector).
  </p>
    <p>
    The 'grid' package stores the clipping path reference that is returned,
    along with the original <code>"GridClipPath"</code>, creating a 
    <code>"GridResolvedClipPath"</code>.  This enhanced clipping path
    object is stored in the pushed viewport so that, when a viewport
    is revisited, 'grid' can send the reference to the clipping path
    as well as the clipping path itself in the call to <code>setClipPath</code>,
    which allows the graphics device to reuse cached clipping paths
    (if it is set up that way).
  </p>
    <p>
    The Cairo device checks whether the <code>ref</code> argument
    to <code>setClipPath</code> is non-NULL, in which case it looks
    up the relevant clipping path in its array of clipping paths
    and reuses that, rather than generating a new clipping path.
  </p>
    <p>
    'grid' releases all clipping paths on a <code>grid.newpage</code>.
  </p>
    <h3>Masks</h3>
    <p>
    A <code>setMask</code> device function has been added to allow
    the graphics engine (or graphics systems) to ask a device to 
    define a mask.  The function takes a <code>mask</code>
    and a <code>ref</code> and should return a reference to
    the mask on the device.  All three values are SEXPs,
    but all the device needs to know about the <code>mask</code> is that
    it is an R function (with no arguments) that the device should
    call to create the mask.  As with clipping paths, the references are
    generated by the device, passed back to the graphics engine, then
    sent in again to the device.  The graphics engine (or graphics
    systems) only store the references and pass them back to the device;
    the references only have
    meaning within the graphics device.
  </p>
    <p>
    There is also a <code>releaseMask</code> device function,
    which takes a reference to a mask so that the graphics engine
    (or graphics systems) can indicate to the device that a mask
    is no longer required.
  </p>
    <p>
    The Cairo device maintains an array of masks.
    When a new mask is requested (with a call to 
    <code>setMask</code>) the device starts a new group
    (<code>cairo_push_group</code>) so that all drawing
    on the device is on a temporary surface, calls the mask function,
    then saves the group as a pattern (<code>cairo_pop_group</code>)
    on the array of masks and returns the index of the mask in that
    array.
  </p>
    <p>
    The 'grid' package stores the mask reference that is returned,
    along with the original <code>"GridMask"</code>, creating a 
    <code>"GridResolvedMask"</code>.  This enhanced mask
    object is stored in the pushed viewport so that, when a viewport
    is revisited, 'grid' can send the reference to the mask
    as well as the mask itself in the call to <code>setMask</code>;
    this allows the graphics device to reuse cached masks
    (if it is set up that way).
  </p>
    <p>
    The Cairo device also keeps track of the current Mask, as an index
    into its mask array.
    This starts as -1, which means there is no mask in effect.
    <code>setMask</code> updates this index, including resetting to
    -1 if sent a <code>NULL</code> mask.
  </p>
    <p>
    The 'grid' package calls <code>setMask</code> whenever a viewport
    is pushed or revisited to update the current mask on the device.
  </p>
    <p>
    The shape-drawing functions on the Cairo device check whether
    the mask is non-negative.  If so, rather than drawing directly,
    they draw to a temporary surface (<code>cairo_push_group</code>,
    <code>cairo_pop_group</code>), collect the result as a pattern,
    then mask the pattern, using the current mask, to draw on the
    main device surface (<code>cairo_mask</code>).
  </p>
    <h3>The <code>pdf</code> device</h3>
    <p>
    Gradients and clipping paths and masks have also been implemented on
    the <code>pdf</code> graphics device.
  </p>
    <p>
    The <code>pdf</code> device maintains an array of "definitions",
    which are basically strings of PDF code.
  </p>
    <p>
    Resolving a gradient (via <code>setPattern</code>) creates
    a definition that contains the PDF code defining the gradient
    and the array index to that definition is returned as the
    reference.
    When a shape is drawn with a gradient fill, code something like
    <code>/Def3 scn</code> is generated to indicate that definition 3 
    (a gradient) is to be used as the fill colour.
    On <code>dev.off</code>, definition strings are written out at the end of
    the PDF file and the link between <code>/Def3</code> and the
    appripriate PDF object number is resolved.
  </p>
    <p>
    Semi-transparent gradients are a bit more complicated because
    they require creating an additional "soft mask" definition.
    In this case, the reference returned is two array indices, one for
    the gradient and one for the soft mask.
    When a shape is drawn with a semi-transparent gradient fill an
    additional piece of code, something like <code>/Def4 gs</code>
    is generated to enforce the soft mask for the gradient fill.
    Again, the actual definition string for the soft mask is written
    out at the end of the PDF file, when links between definition names
    and object numbers are resolved.
  </p>
    <p>
    Resolving a clipping path (via <code>setClipPath</code>) creates
    a definition that contains the PDF code that draws the clipping path.
    Again, the array index of that definition is returned as the reference.
    The <code>setClipPath</code> call also writes the definition string
    out (plus <code>W n</code> to enforce the clipping path), but
    it can simply reuse the definition string (rather than regenerating it)
    if the reference is not <code>NULL</code>.
    A clipping path definition is NOT written out at the end of the file
    (because it is written inline whenever a clipping path is set).
  </p>
    <p>
    A limitation:  the fill rule used by the clipping operator follows
    the device fill rule.  So it is possible to add a path with one
    fill rule, but have the clipping path use a different fill rule.
  </p>
    <p>
    Resolving a mask (via <code>setMask</code>) creates a definition
    that contains the PDF code that defines the mask content.
    Masks are implemented as alpha soft masks.
    The array index of that definition is returned as the reference.
    Mask definitions are stored and written out at the end of the PDF file,
    when links between definition names and object numbers are resolved.
    The PDF device monitors whether a mask is currently defined and,
    when drawing normally, if a mask is defined it is enforced with
    code something like <code>/Def5 gs</code>.
  </p>
    <p>
    Unlike clipping paths, it is valid to nest masks within masks
    (and gradients and clipping paths within masks); masks are 
    essentially self-contained drawings.
    This can be accommodated by the PDF device because all of these
    features are just stored in definitions as the mask content 
    is captured, and then the definitions are written to file at the
    end, and only references to other definitions are recored in
    the mask content.
  </p>
    <p>
    This implementation on the <code>pdf</code> device 
    provides some evidence that the overall design of graphics 
    definitions support has not been too
    tightly coupled with the Cairo graphics devices, which gives
    some hope that other graphics devices will be able to implement
    at least some of these features.
  </p>
    <h2>
      <a name="discussion">6. Discussion</a>
    </h2>
    <p>
    The argument to augment the R graphics engine with new 
    graphics features is a simple one:  R cannot do some things now,
    so we should make it so it can.  But how important is it
    to allow R to produce more sophisticated graphical output ?
  </p>
    <p>
    One motivation for these changes is to allow people to 
    produce more of their figures and diagrams via code.
    One workflow that people employ is to generate a plot using R
    and then use Adobe Illustrator to "touch up" the plot.
    This sort of workflow is not automatable, or reproducible, 
    or shareable, etc.  If we can help people to do everything 
    via code and remove manual steps from workflows, that is a big win.
  </p>
    <p>
    A simple example of the usefulness of clipping paths is the
    ability to clip to (rectangular) rotated viewports (!).
  </p>
    <p>
    From my own perspective, having better support for 
    sophisticated graphical features in R would allow me to
    expand on work already done on importing graphics from
    other systems into R ('grImport', 'grImport2', 'metapost', 
    'dvir', 'displayEngine').  Without these features, it is not
    possible to represent images from other systems properly 
    in R.
  </p>
    <p>
    Anecdotally, I believe that others would like to have the
    ability to make use of additional graphics features too.
    As one piece of hard evidence, this work is being partially funded by 
    a donation from R Studio to the University of Auckland Foundation.
  </p>
    <h3>External graphics devices</h3>
    <p>
    How much work needs to be done to upgrade a graphics device for
    these changes ?
  </p>
    <p>
    A device must implement <code>dev-&gt;setPattern</code>, but it can just
    return <code>NULL</code> if unsupported.  
    A device can also just create a new pattern every time.
    If it returns a meaningful pattern reference, it must do something sensible
    with that reference 
    when provided via <code>R_GE_gcontent.patternFill</code>.
  </p>
    <p>
    A device 
    must implement <code>dev-&gt;releasePattern</code>, but it can just do nothing.
  </p>
    <p>
    There is new <code>R_GE_gcontent.patternFill</code>, but a device
    can just ignore it 
    (because <code>R_GE_gcontext.fill</code> is always set; it will just
    be "transparent" when a pattern fill has been specified).
  </p>
    <p>
    A device 
    must implement <code>dev-&gt;setClipPath</code>, but can just return 
    <code>NULL</code>.
    There are three levels of support:  none, in which case the device
    ignores the clipping path request (and returns NULL);  non-caching,
    where the device sets clipping paths, but returns NULL, so it will
    always generate a new clipping path on every request;  caching,
    where the device sets clipping paths, caches clipping paths,
    and returns a reference to the cache, and the reference only has
    to make sense to the device.
  </p>
    <p>
    A device 
    must implement <code>dev-&gt;releaseClipPath</code>, but can just do nothing.
  </p>
    <p>
    A device must implement
    <code>dev-&gt;setMask</code>, but can just return <code>NULL</code>.
    As with clipping paths, there are three levels of support:
    none, non-caching, and caching.
  </p>
    <p>
    A device 
    must implement <code>dev-&gt;releaseMask</code>, but can just do nothing.
  </p>
    <p>
    As an example of the (minimal) changes necessary to update a device
    (WITHOUT support for any of the new features), the following
    diff shows the changes to get the <code>quartz</code> device
    running on macOS (at r78533).
  </p>
    <pre>
@@ -371,6 +371,12 @@
+static int      RQuartz_setPattern(SEXP pattern, pDevDesc dd);
+static void     RQuartz_releasePattern(int index, pDevDesc dd);
+static SEXP     RQuartz_setClipPath(SEXP path, SEXP ref, pDevDesc dd);
+static void     RQuartz_releaseClipPath(SEXP ref, pDevDesc dd);
+static SEXP     RQuartz_setMask(SEXP path, SEXP ref, pDevDesc dd);
+static void     RQuartz_releaseMask(SEXP ref, pDevDesc dd);

@@ -430,6 +436,13 @@
+    dev-&gt;setPattern      = RQuartz_setPattern;
+    dev-&gt;releasePattern  = RQuartz_releasePattern;
+    dev-&gt;setClipPath     = RQuartz_setClipPath;
+    dev-&gt;releaseClipPath = RQuartz_releaseClipPath;
+    dev-&gt;setMask         = RQuartz_setMask;
+    dev-&gt;releaseMask     = RQuartz_releaseMask;

@@ -1282,6 +1295,24 @@
+static int RQuartz_setPattern(SEXP pattern, pDevDesc dd) {
+    return -1;
+}
+
+static void RQuartz_releasePattern(int index, pDevDesc dd) {} 
+
+static SEXP RQuartz_setClipPath(SEXP path, SEXP ref, pDevDesc dd) {
+    return R_NilValue;
+}
+
+static void RQuartz_releaseClipPath(SEXP ref, pDevDesc dd) {}
+
+static SEXP RQuartz_setMask(SEXP path, SEXP ref, pDevDesc dd) {
+    return R_NilValue;
+}
+
+static void RQuartz_releaseMask(SEXP ref, pDevDesc dd) {}
  </pre>
    <p>
    The plan is to implement at least one caching device (Cairo,
    plus maybe PDF), a non-caching device (always generates new definition
    on every use), and a non-implementing device (does not support 
    features).  These then provide templates for external device
    maintainers.
  </p>
    <h3>Efficiency</h3>
    <p>
    In an unusual move (for me), I have not completely ignored
    efficiency concerns.
  </p>
    <p>
    Definitions are resolved every time a graphics system calls 
    the graphics engine because the graphics engine is a "flat"
    coordinate system whereas the graphics systems 
    (particularly 'grid' units) are dynamic
    and depend on the current drawing context.
  </p>
    <p>
    This may present some challenges for implementing graphical
    definitions efficiently.
    However, the worst case scenario is something like filling
    thousands of data symbols with the same gradient fill.
  </p>
    <p>
    Another issue is revisiting viewports (up/down).  This could
    also generate a lot of redundant recalculations (or very large
    file sizes).  Though not
    at the same scale as the thousands-of-shapes problem, it could
    be more common (?).  This also can happen during calculation
    of things like "grobWidth" units.
  </p>
    <p>
    The inefficiency could bite both in terms of speed and,
    for file-based devices, memory.
  </p>
    <p>
    In both cases, allowing the graphics device to cache its 
    definitions should be beneficial.
  </p>
    <p>
    The plan is to actually do some measurements to demonstrate that
    there is a problem and that caching is helpful (or not).
  </p>
    <h3>TODOs</h3>
    <p>
    Neither Cairo nor PDF devices have currently attempted to 
    include text output in clipping paths or masks.
  </p>
    <p>
    The R graphics engine does not accommodate the idea of a 
    gradient fill within text.
  </p>
    <p>
    The PDF device does not (yet) allow rasters within masks.
  </p>
    <h3>Issues</h3>
    <!--
  <p>
    I have put "patterns.c" in src/main so that the X11 module (and
    external devices) can see the C API for gradient objects.
    This COULD go in grDevices/src/, but that would require an awful
    "stub" like there is src/main/colors.c for grDevices/src/colors.c (?)
  </p>
  -->
    <p>
    What to do about pattern fill on multiple shapes from single
    grob: 
    <code>grid.rect(width=1:2/3, gp=gpar(gradientFill=linearGradient()))</code>
    Currently just resolving pattern based on bounding box
    of all shapes.
  </p>
    <p>
    The current implementation of pattern fills in 'grid' "nicely" 
    incorporates them into the gpar(fill=) interface.
    This may have implications for packages that build on 'grid'
    if they try to manipulate 'grid' gpars in any way, other than
    just setting them (e.g., 'gridSVG' converts gpar values to
    SVG display attributes).
  </p>
    <p>
    These changes introduce some "modal" behaviour (like 
    whether the device is "appending" or "drawing");  how to
    make sure we elegantly unwind when an error occurs (e.g.,
    when hit an error while playing/recording a clipping path) ?
    One defence being employed for Cairo and PDF devices is
    to only produce warnings rather than errors when things go
    wrong (in the case of PDF, ask the use politely to shut down
    the PDF device).  Also, modes are reset on new page, so it 
    may be possible to recover a corrupted device by starting a new page.
  </p>
    <p>
    What will the impact be on saved/restored plots ?
    (the graphics engine display list and snapshots thereof)
    I have some test cases working within-session.
    It would certainly be a bad idea to save from R 4 and replay
    in R 3 (though the reverse should be ok?).
  </p>
    <p>
    The fact that clipping paths (mostly) and masks can be arbitrary
    'grid' grobs places a reasonable burden on the graphics device.
    The device has to evaluate an R function and capture the
    resulting output.  A possible future path for devices that 
    cannot meet these demands may be to allow alternate objects 
    as clipping paths and masks.  Currently, the SEXP sent to the
    device is an R function, but that could conceivably be 
    limited to simpler R objects, like a simpler description of 
    one or more shapes.  That might make the device's job a LOT
    easier.
  </p>
    <h3>'gridSVG'</h3>
    <p>
    Reasons for keeping 'gridSVG':  still the only way to 
    support some stuff (e.g., Cairo does not support filters);
    still the only way to retain structure and labelling when export.
  </p>
    <p>
    The impact on 'gridSVG' may be interesting.  There may be differences
    between the way that features are implemented in 'grid' vs 'gridSVG'.
    For example, gradient fills might be added to <code>gpar</code>
    in 'grid', rather than creating a separate class of grob (as in 'gridSVG').
    This means that 'gridSVG' may need updating to work with 
    new 'grid' gradients. (Yes!)
  </p>
    <p>
    'grImport2' is another interesting case - it may still end up with 
    <code>ext=gridSVG</code> as well as being able to draw directly
    to normal R graphics devices.
  </p>
    <h3>Fonts</h3>
    <p>
    Proper font support is another issue entirely.
    Currently addressed by packages like 'showtext' and 'extrafont'.
    Maybe a future project.
  </p>
    <h3>Extensions</h3>
    <p>
    It would be nice if the graphics device API allowed for
    people to write R code that talked directly to the 
    graphics device without having to be controlled by (and
    filtered through) the
    graphics engine. This would allow, for example, people
    to access features on graphics devices that are still
    not supported by the graphics engine 
    (sort of like what 'showtext' sneakily does now to hijack
    text rendering; 'tikzDevice'
    also does something like this for creating "tags" in tikZ
    output ?).  This would be a little like
    DVI specials (?)
    TODO: look at what 'showtext' and 'tikzDevice' need to do
    and how they currently work around the graphics engine.
    Another example that has been mentioned is hyperlinks.
  </p>
    <p>
    Probably also best as a separate, future project.
  </p>
    <h2>Footnotes</h2>
    <div>
      <p class="footnote"><sup>1</sup><a name="clippingpathworkaround"></a>
      It is actually possible to get this particular result currently in
      R graphics.  We can generate a path consisting of the border of
      the entire image with the border of New Zealand inside it (i.e., a
      rectangular path with a hole the shape of New Zealand) and fill
      that with opaque white.  However, that sort of workaround is more
      awkward and often runs into difficulties, for example, if we want
      to add other output to the image, but not obscure it with the
      opaque white fill.  In general, we can generate may different
      graphical results just with the existing R graphics features, but
      we may have to work very hard to get what we want.  It could be
      said that all this proposal is aiming for is greater convenience,
      but in some cases it is MUCH greater convenience.
    </p>
    </div>
    <hr>
    <p><a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img class="CC" alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a><br><span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">This document</span>
    by <span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Paul
    Murrell</span> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative
    Commons Attribution 4.0 International License</a>.
  </p>
  </body>
</html>
